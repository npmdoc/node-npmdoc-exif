<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/gomfunkel/node-exif#readme"

    >exif (v0.6.0)</a>
</h1>
<h4>A node.js library to extract Exif metadata from images.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.exif">module exif</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.exif">
            function <span class="apidocSignatureSpan"></span>exif
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage">
            function <span class="apidocSignatureSpan">exif.</span>ExifImage
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">exif.</span>ExifImage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">exif.</span>TAGS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.exif.ExifImage">module exif.ExifImage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage.ExifImage">
            function <span class="apidocSignatureSpan">exif.</span>ExifImage
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">exif.ExifImage.</span>TAGS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.exif.ExifImage.prototype">module exif.ExifImage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage.prototype.extractExifData">
            function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>extractExifData
            <span class="apidocSignatureSpan">(data, start, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage.prototype.extractExifEntry">
            function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>extractExifEntry
            <span class="apidocSignatureSpan">(data, entryOffset, tiffOffset, isBigEndian, tags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage.prototype.loadImage">
            function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>loadImage
            <span class="apidocSignatureSpan">(image, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.exif.ExifImage.prototype.processImage">
            function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>processImage
            <span class="apidocSignatureSpan">(source, data, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.exif" id="apidoc.module.exif">module exif</a></h1>


    <h2>
        <a href="#apidoc.element.exif.exif" id="apidoc.element.exif.exif">
        function <span class="apidocSignatureSpan"></span>exif
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExifImage(options, callback) {
  if (!(this instanceof ExifImage)) {
    if (typeof(options)===&#x22;string&#x22;) {
      options = {
          image: options
      }
    }

    assert(typeof(options)===&#x22;object&#x22;, &#x22;Invalid options object&#x22;);

    var exifImage = new ExifImage(options, function(error, data) {
      if (error) {
        return callback(error);
      }

      callback(null, data, options.image);
    });

    return exifImage;
  }

  if (typeof(options)===&#x22;string&#x22;) {
    options= {
        image: options
    }
  } else if (options instanceof Buffer) {
    options= {
        image: options
    }
  }

  var ops={};
  if (options) {
    for(var k in options) {
      ops[k]=options[k];
    }
  }
  this.options=ops;

  // Default option values
  [&#x22;ifd0MaxEntries&#x22;, &#x22;ifd1MaxEntries&#x22;, &#x22;maxGpsEntries&#x22;, &#x22;maxInteroperabilityEntries&#x22;, &#x22;agfaMaxEntries&#x22;, &#x22;epsonMaxEntries&#x22;,
     &#x22;fujifilmMaxEntries&#x22;, &#x22;olympusMaxEntries&#x22;, &#x22;panasonicMaxEntries&#x22;, &#x22;sanyoMaxEntries&#x22;].forEach(function(p) {
       if (ops[p]===undefined) {
         ops[p]=DEFAULT_MAX_ENTRIES;
       }
     });

  this.exifData = {
    image : {},                 // Information about the main image
    thumbnail : {},             // Information about the thumbnail
    exif : {},                  // Exif information
    gps : {},                   // GPS information
    interoperability: {},       // Exif Interoperability information
    makernote : {}              // Makernote information
  };

  this.offsets={};
  if (ops.tiffOffsets) {
    exifData.offsets=offsets;
  }

  debug(&#x22;New ExifImage options=&#x22;,options);

  if (!ops.image) {
    // If options image is not specified, the developper must call loadImage() to parse the image.
//    callback(new Error(&#x27;You have to provide an image, it is pretty hard to extract Exif data from nothing...&#x27;));
    return;
  }

  if (typeof callback !== &#x27;function&#x27;) {
    throw new Error(&#x27;You have to provide a callback function.&#x27;);
  }

  var self=this;
  setImmediate(function() {
    self.loadImage(ops.image, function (error, exifData) {
      if (error) {
        return callback(error);
      }

      callback(null, exifData, ops.image);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.exif.ExifImage" id="apidoc.element.exif.ExifImage">
        function <span class="apidocSignatureSpan">exif.</span>ExifImage
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExifImage(options, callback) {
  if (!(this instanceof ExifImage)) {
    if (typeof(options)===&#x22;string&#x22;) {
      options = {
          image: options
      }
    }

    assert(typeof(options)===&#x22;object&#x22;, &#x22;Invalid options object&#x22;);

    var exifImage = new ExifImage(options, function(error, data) {
      if (error) {
        return callback(error);
      }

      callback(null, data, options.image);
    });

    return exifImage;
  }

  if (typeof(options)===&#x22;string&#x22;) {
    options= {
        image: options
    }
  } else if (options instanceof Buffer) {
    options= {
        image: options
    }
  }

  var ops={};
  if (options) {
    for(var k in options) {
      ops[k]=options[k];
    }
  }
  this.options=ops;

  // Default option values
  [&#x22;ifd0MaxEntries&#x22;, &#x22;ifd1MaxEntries&#x22;, &#x22;maxGpsEntries&#x22;, &#x22;maxInteroperabilityEntries&#x22;, &#x22;agfaMaxEntries&#x22;, &#x22;epsonMaxEntries&#x22;,
     &#x22;fujifilmMaxEntries&#x22;, &#x22;olympusMaxEntries&#x22;, &#x22;panasonicMaxEntries&#x22;, &#x22;sanyoMaxEntries&#x22;].forEach(function(p) {
       if (ops[p]===undefined) {
         ops[p]=DEFAULT_MAX_ENTRIES;
       }
     });

  this.exifData = {
    image : {},                 // Information about the main image
    thumbnail : {},             // Information about the thumbnail
    exif : {},                  // Exif information
    gps : {},                   // GPS information
    interoperability: {},       // Exif Interoperability information
    makernote : {}              // Makernote information
  };

  this.offsets={};
  if (ops.tiffOffsets) {
    exifData.offsets=offsets;
  }

  debug(&#x22;New ExifImage options=&#x22;,options);

  if (!ops.image) {
    // If options image is not specified, the developper must call loadImage() to parse the image.
//    callback(new Error(&#x27;You have to provide an image, it is pretty hard to extract Exif data from nothing...&#x27;));
    return;
  }

  if (typeof callback !== &#x27;function&#x27;) {
    throw new Error(&#x27;You have to provide a callback function.&#x27;);
  }

  var self=this;
  setImmediate(function() {
    self.loadImage(ops.image, function (error, exifData) {
      if (error) {
        return callback(error);
      }

      callback(null, exifData, ops.image);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.exif.ExifImage" id="apidoc.module.exif.ExifImage">module exif.ExifImage</a></h1>


    <h2>
        <a href="#apidoc.element.exif.ExifImage.ExifImage" id="apidoc.element.exif.ExifImage.ExifImage">
        function <span class="apidocSignatureSpan">exif.</span>ExifImage
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExifImage(options, callback) {
  if (!(this instanceof ExifImage)) {
    if (typeof(options)===&#x22;string&#x22;) {
      options = {
          image: options
      }
    }

    assert(typeof(options)===&#x22;object&#x22;, &#x22;Invalid options object&#x22;);

    var exifImage = new ExifImage(options, function(error, data) {
      if (error) {
        return callback(error);
      }

      callback(null, data, options.image);
    });

    return exifImage;
  }

  if (typeof(options)===&#x22;string&#x22;) {
    options= {
        image: options
    }
  } else if (options instanceof Buffer) {
    options= {
        image: options
    }
  }

  var ops={};
  if (options) {
    for(var k in options) {
      ops[k]=options[k];
    }
  }
  this.options=ops;

  // Default option values
  [&#x22;ifd0MaxEntries&#x22;, &#x22;ifd1MaxEntries&#x22;, &#x22;maxGpsEntries&#x22;, &#x22;maxInteroperabilityEntries&#x22;, &#x22;agfaMaxEntries&#x22;, &#x22;epsonMaxEntries&#x22;,
     &#x22;fujifilmMaxEntries&#x22;, &#x22;olympusMaxEntries&#x22;, &#x22;panasonicMaxEntries&#x22;, &#x22;sanyoMaxEntries&#x22;].forEach(function(p) {
       if (ops[p]===undefined) {
         ops[p]=DEFAULT_MAX_ENTRIES;
       }
     });

  this.exifData = {
    image : {},                 // Information about the main image
    thumbnail : {},             // Information about the thumbnail
    exif : {},                  // Exif information
    gps : {},                   // GPS information
    interoperability: {},       // Exif Interoperability information
    makernote : {}              // Makernote information
  };

  this.offsets={};
  if (ops.tiffOffsets) {
    exifData.offsets=offsets;
  }

  debug(&#x22;New ExifImage options=&#x22;,options);

  if (!ops.image) {
    // If options image is not specified, the developper must call loadImage() to parse the image.
//    callback(new Error(&#x27;You have to provide an image, it is pretty hard to extract Exif data from nothing...&#x27;));
    return;
  }

  if (typeof callback !== &#x27;function&#x27;) {
    throw new Error(&#x27;You have to provide a callback function.&#x27;);
  }

  var self=this;
  setImmediate(function() {
    self.loadImage(ops.image, function (error, exifData) {
      if (error) {
        return callback(error);
      }

      callback(null, exifData, ops.image);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.exif.ExifImage.prototype" id="apidoc.module.exif.ExifImage.prototype">module exif.ExifImage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.exif.ExifImage.prototype.extractExifData" id="apidoc.element.exif.ExifImage.prototype.extractExifData">
        function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>extractExifData
        <span class="apidocSignatureSpan">(data, start, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractExifData = function (data, start, length) {

  var exifData=this.exifData;
  var tiffOffset = start + 6;
  var ifdOffset, numberOfEntries;
  var noPadding = (this.options.noPadding!==false);

  this.offsets.tiff=tiffOffset;

  // Exif data always starts with Exif\0\0
  if (data.toString(&#x27;utf8&#x27;, start, tiffOffset) != &#x27;Exif\0\0&#x27;) {
    throw new Error(&#x27;The Exif data is not valid.&#x27;);
  }

  // After the Exif start we either have 0x4949 if the following data is
  // stored in big endian or 0x4D4D if it is stored in little endian
  if (data.getShort(tiffOffset) == 0x4949) {
    this.isBigEndian = false;

  } else if (data.getShort(tiffOffset) == 0x4D4D) {
    this.isBigEndian = true;

  } else {
    throw new Error(&#x27;Invalid TIFF data! Expected 0x4949 or 0x4D4D at offset &#x27;+(tiffOffset)+&#x27; but found 0x&#x27;+data[tiffOffset].toString
(16).toUpperCase()+data[tiffOffset + 1].toString(16).toUpperCase()+&#x22;.&#x22;);
  }

  debug(&#x22;BigEndian=&#x22;,this.isBigEndian);

  // Valid TIFF headers always have 0x002A here
  if (data.getShort(tiffOffset + 2, this.isBigEndian) != 0x002A) {
    var expected = (this.isBigEndian) ? &#x27;0x002A&#x27; : &#x27;0x2A00&#x27;;
    throw new Error(&#x27;Invalid TIFF data! Expected &#x27;+expected+&#x27; at offset &#x27;+(tiffOffset + 2)+&#x27; but found 0x&#x27;+data[tiffOffset + 2].
toString(16).toUpperCase()+data[tiffOffset + 3].toString(16).toUpperCase()+&#x22;.&#x22;);
  }

  /********************************* IFD0 **********************************/

  // Offset to IFD0 which is always followed by two bytes with the amount of
  // entries in this IFD
  ifdOffset = tiffOffset + data.getLong(tiffOffset + 4, this.isBigEndian);
  this.offsets.ifd0=ifdOffset;

  numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
  if (this.options.ifd0MaxEntries) {
    numberOfEntries=Math.min(numberOfEntries, this.options.ifd0MaxEntries);
  }

  debug(&#x22;IFD0 ifdOffset=&#x22;,ifdOffset, &#x22;numberOfEntries=&#x22;, numberOfEntries);

  // Each IFD entry consists of 12 bytes which we loop through and extract
  // the data from
  for (var i = 0; i &#x3c; numberOfEntries; i++) {
    var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);
    if (!exifEntry) {
      continue;
    }

    if (exifEntry.tagId===0xEA1C &#x26;&#x26; noPadding) {
      continue;
    }

    exifData.image[exifEntry.tagName] = exifEntry.value;
  }

  debug(&#x22;IFD0 parsed&#x22;, exifData.image);

  /********************************* IFD1 **********************************/

  // Check if there is an offset for IFD1. If so it is always followed by two
  // bytes with the amount of entries in this IFD, if not there is no IFD1
  var nextIfdOffset = data.getLong(ifdOffset + 2 + (numberOfEntries * 12), this.isBigEndian)
  if (nextIfdOffset != 0x00000000) {
    ifdOffset = tiffOffset + nextIfdOffset;
    this.offsets.ifd1=ifdOffset;
    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
    if (this.options.ifd1MaxEntries) {
      numberOfEntries=Math.min(numberOfEntries, this.options.ifd1MaxEntries);
    }

    debug(&#x22;IFD1 ifdOffset=&#x22;,ifdOffset, &#x22;numberOfEntries=&#x22;, numberOfEntries);

    // Each IFD entry consists of 12 bytes which we loop through and extract
    // the data from
    for (var i = 0; i &#x3c; numberOfEntries; i++) {
      var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);
      if (!exifEntry) {
        continue;
      }

      if (exifEntry.tagId===0xEA1C &#x26;&#x26; noPadding) {
        continue;
      }

      exifData.thumbnail[exifEntry.tagName] = exifEntry.value;
    }

    if (this.options.fixThumbnailOffset) {
      var thumbnailOffset=exifData.thumbnail[ExifImage.TAGS.exif[0x0201]];
      if (thumbnailOffset) {
        debug(&#x22;IFD1 fix thumbnail offset, add=&#x22;,this.offsets.tiff);

        exifData.thumbnail[ExifImage.TAGS.exif[0x0201]]+=this.offsets.tiff;
      }
    }

    debug(&#x22;IFD1 parsed&#x22;, exifData.thumbnail);
  }

  /******************************* ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.exif.ExifImage.prototype.extractExifEntry" id="apidoc.element.exif.ExifImage.prototype.extractExifEntry">
        function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>extractExifEntry
        <span class="apidocSignatureSpan">(data, entryOffset, tiffOffset, isBigEndian, tags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractExifEntry = function (data, entryOffset, tiffOffset, isBigEndian, tags) {

  var entry = {
    tag : data.slice(entryOffset, entryOffset + 2),
    tagId : null,
    tagName : null,
    format : data.getShort(entryOffset + 2, isBigEndian),
    components : data.getLong(entryOffset + 4, isBigEndian),
    valueOffset: null,
    value : []
  }

  entry.tagId = entry.tag.getShort(0, isBigEndian);

  // The tagId may correspond to more then one tagName so check which
  if (tags &#x26;&#x26; tags[entry.tagId] &#x26;&#x26; typeof tags[entry.tagId] == &#x22;function&#x22;) {
    entry.tagName = tags[entry.tagId].call(this, entry);
    if (!entry.tagName) {
      return false;
    }

  // The tagId corresponds to exactly one tagName
  } else if (tags &#x26;&#x26; tags[entry.tagId]) {
    entry.tagName = tags[entry.tagId];
    if (entry.tagName===undefined) {
      return false;
    }

  // The tagId is not recognized
  } else {
    return false;
  }

  switch (entry.format) {

    case 0x0001: // unsigned byte, 1 byte per component
      entry.valueOffset = (entry.components &#x3c;= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getByte(entry.valueOffset + i));
      break;

    case 0x0002: // ascii strings, 1 byte per component
      entry.valueOffset = (entry.components &#x3c;= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      entry.value = data.getString(entry.valueOffset, entry.components);
      if (entry.value[entry.value.length - 1] === &#x22;\u0000&#x22;) // Trim null terminated strings
        entry.value = entry.value.substring(0, entry.value.length - 1);
      break;

    case 0x0003: // unsigned short, 2 byte per component
      entry.valueOffset = (entry.components &#x3c;= 2) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getShort(entry.valueOffset + i * 2, isBigEndian));
      break;

    case 0x0004: // unsigned long, 4 byte per component
      entry.valueOffset = (entry.components == 1) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getLong(entry.valueOffset + i * 4, isBigEndian));
      break;

    case 0x0005: // unsigned rational, 8 byte per component (4 byte numerator and 4 byte denominator)
      entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getLong(entry.valueOffset + i * 8, isBigEndian) / data.getLong(entry.valueOffset + i * 8 + 4, isBigEndian
));
      break;

    case 0x0006: // signed byte, 1 byte per component
      entry.valueOffset = (entry.components &#x3c;= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getSignedByte(entry.valueOffset + i));
      break;

    case 0x0007: // undefined, 1 byte per component
      entry.valueOffset = (entry.components &#x3c;= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      entry.value.push(data.slice(entry.valueOffset, entry.valueOffset + entry.components));
      break;

    case 0x0008: // signed short, 2 byte per component
      entry.valueOffset = (entry.components &#x3c;= 2) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getSignedShort(entry.valueOffset + i * 2, isBigEndian));
      break;

    case 0x0009: // signed long, 4 byte per component
      entry.valueOffset = (entry.components == 1) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
      for (var i = 0; i &#x3c; entry.components; i++)
        entry.value.push(data.getSignedLong(entry.valueOffset + i * 4, isBigEndian));
      break;

    case 0x000A: // signed r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.exif.ExifImage.prototype.loadImage" id="apidoc.element.exif.ExifImage.prototype.loadImage">
        function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>loadImage
        <span class="apidocSignatureSpan">(image, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadImage = function (image, callback) {
  assert(typeof(callback)===&#x22;function&#x22;, &#x22;Callback must be a function&#x22;);

  var self = this;

  debug(&#x22;loadImage image=&#x22;, image);

  if (image.constructor.name === &#x27;Buffer&#x27;) {
    this.processImage(&#x22;Buffer&#x22;, image, callback);
    return;
  }

  if (image.constructor.name === &#x27;String&#x27;) {
    fs.readFile(image, function (error, data) {
      if (error) {
        callback(new Error(&#x27;Encountered the following error while trying to read given image: &#x27;+error));
        return;
      }

      self.processImage(&#x22;File: &#x22;+image, data, callback);
    });
    return;
  }

  callback(new Error(&#x27;Given image is neither a buffer nor a file, please provide one of these.&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.exif.ExifImage.prototype.processImage" id="apidoc.element.exif.ExifImage.prototype.processImage">
        function <span class="apidocSignatureSpan">exif.ExifImage.prototype.</span>processImage
        <span class="apidocSignatureSpan">(source, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processImage = function (source, data, callback) {
  assert(typeof(source)===&#x22;string&#x22;, &#x22;Source must be a string&#x22;);
  assert(typeof(callback)===&#x22;function&#x22;, &#x22;Callback must be a function&#x22;);

  var offset = 0;

  if (data[offset++] != 0xFF || data[offset++] != 0xD8) {
    var e=new Error(&#x27;The given image is not a JPEG and thus unsupported right now.&#x27;);
    e.source=source;
    e.code=&#x22;NOT_A_JPEG&#x22;;
    callback(e);
    return;
  }

  this.imageType = &#x27;JPEG&#x27;;

  while (offset &#x3c; data.length) {

    if (data[offset++] != 0xFF) {
      break;
    }

    if (data[offset++] == 0xE1) {
      try {
        this.extractExifData(data, offset + 2, data.getShort(offset, true) - 2);

      } catch (error) {
        error.code=&#x22;PARSING_ERROR&#x22;;
        error.source=source;

        debug(&#x22;Extract exif data error source=&#x22;, source, &#x22;offset=&#x22;, offset, &#x22;error=&#x22;,error);

        callback(error);
        return;
      }

      debug(&#x22;Extract exif data success source=&#x22;, source, &#x22;exifData=&#x22;,this.exifData);

      callback(null, this.exifData);
      return;
    }

    offset += data.getShort(offset, true);
  }

  var e2=new Error(&#x27;No Exif segment found in the given image.&#x27;);
  e2.source=source;
  e2.code=&#x22;NO_EXIF_SEGMENT&#x22;;

  callback(e2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
